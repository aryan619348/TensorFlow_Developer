
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras import models
# load fashion MNIST data from the keras library
mnist = tf.keras.datasets.fashion_mnist
#creating training and testing data
(training_images, training_labels), (test_images, test_labels) = mnist.load_data()
#first convolution expects a single tensor containing everything,
# so instead of 60,000 28x28x1 items in a list, we have a single 4D list that is 60,000x28x28x1
training_images=training_images.reshape(60000, 28, 28, 1)
training_images=training_images / 255.0
test_images = test_images.reshape(10000, 28, 28, 1)
test_images=test_images/255.0

# design the model:
# 1st Conv2d= we are generating 64 filters that are 3X3, relu to remove -ve vals and input is 28X28 with 1 for color depth
# Then Max pooling of size 2X2
# followed by another Convolution and another pool on top of the existing one thus by the time the data reaches flatten
# it been quartered twice and thus the content is much simpler so that the convolutions filter the image to have the features that determine the output

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(64, (3,3), activation='relu', input_shape=(28, 28, 1)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(10, activation='softmax')
])

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy',metrics=['accuracy'])
model.summary() # to inspect the layers of the model
model.fit(training_images,training_labels,epochs=5)
print("testing...")
test_loss = model.evaluate(test_images,test_labels)


#VISUALIZING IMAGE THROUGH THE CONVOLUTIONS

print(test_labels[:100])

f, axarr=plt.subplots(3,4)
# 3 images with label 9 = shoes, the heatmap will isolate the shoelaces
first_image=0
second_image=23
third_image=28
# Keras API return each CNN, pooling, dense, etc as layers
# thus using layers API we can look at each layers out put so we create a list of each layers output
CONVOLUTION_NUMBER = 1

layer_outputs = [layer.output for layer in model.layers]
activation_model = tf.keras.models.Model(inputs = model.input, outputs = layer_outputs)
for x in range(0,4):
    f1 = activation_model.predict(test_images[first_image].reshape(1, 28, 28, 1))[x]
    axarr[0,x].imshow(f1[0, : , :, CONVOLUTION_NUMBER], cmap='inferno')
    axarr[0,x].grid(False)
    f2 = activation_model.predict(test_images[second_image].reshape(1, 28, 28, 1))[x]
    axarr[1,x].imshow(f2[0, : , :, CONVOLUTION_NUMBER], cmap='inferno')
    axarr[1,x].grid(False)
    f3 = activation_model.predict(test_images[third_image].reshape(1, 28, 28, 1))[x]
    axarr[2,x].imshow(f3[0, : , :, CONVOLUTION_NUMBER], cmap='inferno')
    axarr[2,x].grid(False)

plt.show()

